#include <stdio.h>
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <regex>
#include <algorithm>
#include <map>

using namespace std;

fstream infile_instr;
fstream infile_at;
fstream outfile_dyn;

// Some functions run as application code in Janus may require some maintenance work to be done
// prior to being executed. In order to hide the underlying details of Janus and DynamoRIO,
// the maintenance logic is encapsulated in some helper functions within Janus. The map below
// contains the code that must be inserted prior to any function run by DynamoRIO as application code.
map<string, string> func_name_to_prologue = {
    {
    "run_thread",
    "do_pre_thread_creation_maintenance(janus_context);"
    }
};

map<int, string> num_rule_to_prologue; // Map needed to precompute which function handlers will
// need the additional prologue code; note that this only considers functions from the 
// ".instr" file but not the ".at" file

map<int, string> num_rule_to_thread_constraints; // Map needed to precompute which threads are allowed to execute
// a given part of the instrumentation code. This will be filled using information from
// ".thread_specific_handlers" generated by CodeGen.cpp

void compute_num_rule_to_prologue(const string &filename);

void compute_num_rule_to_thread_constraints(const string &filename);

int main(int argc, char** argv){
    if(argc < 2){
        cout << "Expecting filename as input" << endl;
        return 1;
    }

    string filename = argv[1];

    compute_num_rule_to_prologue(filename);
    compute_num_rule_to_thread_constraints(filename);

    infile_instr.open(filename + ".instr", ios::in);
    infile_at.open(filename + ".at", ios::in);
    outfile_dyn.open(filename + ".dyn", ios::out | ios::trunc);

    int num_rule = 0;
    int num_at_rule = 0;
    string line;
    while(getline(infile_instr, line)){
        if(line != ""){
            if(regex_match(line, regex("func_[0-9]*:"))){
                if(num_rule > 0){
                    outfile_dyn << "}" << endl;
                }
                num_rule++;
                outfile_dyn << "void handler_" + to_string(num_rule) + "(JANUS_CONTEXT){" << endl;

                // Adding any thread constraints for the handler
                const string thread_constraints = num_rule_to_thread_constraints[num_rule];
                if (thread_constraints.size()) {
                    outfile_dyn << "    " + thread_constraints << endl;

                }

                // Adding any required prologue for the handler
                const string prologue = num_rule_to_prologue[num_rule];
                if (prologue.size()) {
                    outfile_dyn << "    " + prologue << endl;
                }

                outfile_dyn << "    instr_t * trigger = get_trigger_instruction(bb,rule);" << endl;
                outfile_dyn << "    uint64_t bitmask = rule->reg1;" << endl;

                // outfile_dyn << "    int index = get_index_instruction(bb,rule);" << endl;
                continue;
            }
            outfile_dyn << "    " << line << endl;
        }
    }
    while(getline(infile_at, line)){
        if(line != ""){
            if(regex_match(line, regex(".*func_[0-9]*.*"))){
                if(num_rule > 0){
                    outfile_dyn << "}" << endl;
                }
                num_rule++;
                num_at_rule++;
                outfile_dyn << "void handler_" + to_string(num_rule) + "(JANUS_CONTEXT){" << endl;
                outfile_dyn << "    instr_t * trigger = get_trigger_instruction(bb,rule);" << endl;
                outfile_dyn<<  "    dr_ctext = drcontext;"<<endl; 
                outfile_dyn << "    uint64_t bitmask = rule->reg1;" << endl;
                // outfile_dyn << "    int index = get_index_instruction(bb,rule);" << endl;
                continue;
            }
            outfile_dyn << line << endl;
        }
    }
    if(num_rule > 0 && num_at_rule == 0)
        outfile_dyn << "}" << endl;

    outfile_dyn<<"void create_handler_table(){"<<endl;
    
    for(int i=0; i<num_rule; i++){
        outfile_dyn<<"    htable["<<i<<"] = (void*)&handler_"<<i+1<<";"<<endl; 
    }

    outfile_dyn<<"}"<<endl;

    infile_instr.close();
    outfile_dyn.close();

    return 0;
}

void compute_num_rule_to_prologue(const string &filename)
{
    int num_rule = 0;
    string line;

    infile_instr.open(filename + ".instr", ios::in);
    while(getline(infile_instr, line)){
        if(!line.size()) {
            continue;
        }

        if(regex_match(line, regex("func_[0-9]*:"))) {
            num_rule++;
        }
        if(regex_match(line, regex("insert_function_call_as_application.*"))) {
            string prologue;
            for (auto it = func_name_to_prologue.begin(); it != func_name_to_prologue.end(); ++it) {
                const string func_name = it->first;

                if (regex_match(line, regex(".*" + func_name + ".*"))) {
                    prologue = it->second;
                    break;
                }
            }

            if (prologue.size()) {
                num_rule_to_prologue.insert(make_pair(num_rule, prologue));
            }
        }
    }

    infile_instr.close();
}

void compute_num_rule_to_thread_constraints(const string &filename)
{
    string line;
    fstream thread_specific_handlers_file;
    thread_specific_handlers_file.open(filename + ".thread_specific_handlers", ios::in);

    while(getline(thread_specific_handlers_file, line)){
        if(!line.size()) {
            continue;
        }

        if (count(line.begin(), line.end(), ' ') != 1) {
            cout << "ERROR: Invalid format for line in .thread_specific_handlers: " << line << endl;
        }

        const int num_rule = stoi(line.substr(0, line.find(" ")));
        const string thread_name = line.substr(line.find(" ") + 1, line.size());

        const string indent = "    ";
        const string thread_constraint = (
            "if (!(" + thread_name + " && dr_get_thread_id(drcontext) == " + thread_name + "->pid)) {\n" + 
            indent + indent + "std::cout << \"Only " + thread_name + " should be instrumented through handler_" + to_string(num_rule) + ".\" << std::endl;\n" +
            indent + indent + "std::cout << \"TID \" << dr_get_thread_id(drcontext) << \" will skipp instrumenting.\" << std::endl;\n" +
            indent + indent + "return;\n" + 
            indent + "}"
        );

        num_rule_to_thread_constraints.insert(make_pair(num_rule, thread_constraint));
    }

    thread_specific_handlers_file.close();
}